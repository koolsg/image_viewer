# Plan, Specify, and Implement with Spec Kit - YouTube
https://www.youtube.com/watch?v=VfBLlAN5zdQ&t=256s
[00:05] 안녕, Dan. 안녕, James. 만나서 반가워. 만나서 반가워. 휴가 때야. 준비됐어. 준비됐어. 시작하자. 좋아. 너희들이 나를 잘 알듯이, 우리는 계획, 지정, 그리고 실제 계획, 실제 개발에 대해 이야기하는 걸 좋아해. 예. 그렇게 생각해. 지금까지 오늘 사람들에게 GitHub Copilot, VS Code, Visual Studio에 대한 많은 것들을 보여줬어, 맞지?
[00:38] 그리고 종종 우리가 데모를 하거나 실제로 소프트웨어를 작성할 때, 우리는 아이디어나 버그를 가지고 있고, 그것을 할당하고 에이전트에게 무엇을 할지 말해, 맞지? 그리고 나는 최근에 한 회사와 회의를 했는데, 그들은 말했어, "나는 2개월 전에 어떻게 일했는지 지금과 완전히 다르다고. 왜냐하면 나는 방금 설명한 것처럼 머릿속에 아이디어가 있었고, 두세 문장을 쓰고 AI가 그것을 알아서 처리하게 했으니까." 그리고 그것의 장점은 머릿속에서 코드로 빠르게 갔다는 거야. 하지만 단점은 내가 실제로 레일을 주지 않았다는 거야.
[01:09] 계획, 스펙에 대한 레일을 주지 않았어, 맞지? 그래서 VS Code의 계획 모드는 우리가 아이디어를 가지고 그것을 실행할 수 있는 계획으로 바꾸는 데 도움이 돼. 우리가 스펙 기반 개발에 대해 생각할 때, 그것은 조금 다르지. 그리고 그것이 우리가 오늘 이야기하고 싶은 거야. 예. 예. 그래서 스펙 기반 개발이란 무엇일까? 그리고 왜 사람들이 관심을 가질까? 예.
[01:41] 스펙 기반 개발은 기본적으로 실천으로, 사람들은 그것을 마법 같은 새로운 것으로 생각해, 맞아? "오, 에이전트 워크플로우와 스펙 기반이고 모든 게 마법이야." 현실에서는, 그것은 본질적으로 AI 모델을 위한 가드레일을 공식화하는 거야, 맞아? 왜냐하면 많은 고객과 이야기할 때, 그들은 vibe 코딩을 시도했어, 우리 모두가 했듯이, 맞아? 흥미롭지. 웹사이트를 구축하기 시작하고, 스타일과 버튼과 헤더가 빛나는 걸 보고, 꽤 멋지다고 생각해.
[02:12] 하지만 프로덕션 소프트웨어를 구축할 때, 유지보수해야 하는 소프트웨어, 미래에 초기 프로토타입을 넘어 발전해야 하는 소프트웨어, 그 vibe 코딩 접근법은 확장되지 않아. 왜냐하면 AI가 반드시 맛이나 컨벤션을 적용해야 하는 감각을 가지고 있지 않으니까. 그래서 자연스럽게, 사용하는 모델은 자체 아키텍처 선택을 할 거야, 맞아? 특정 웹 프레임워크를 선택할 수 있어, 우리가 지시를 주지 않았다면. 특정 컴포넌트 구성 방식, CSS, 모든 걸 구성하는 방식을 선택할 수 있어.
[02:42] 그리고 그것은 확장에서 문제가 돼. 왜냐하면 이러한 많은 결정은 일방향 문이 아니기 때문에, 그것들을 뒤집을 수 있지만, 미래에 구축하고 나서, 쇼핑 카트를 추가하고 싶을 때, 사용하는 라이브러리가 호환되지 않는 걸 깨달아. 그래서 스스로를 코너에 몰아넣어, "좋아, 이제 어떻게 빠져나갈까?" 그래서 스펙 기반 개발은 우리가 구축하려는 기능 요구사항을 개요로 하는 스펙 문서를 작성하는 프로세스야. 우리가 구축하려는 걸 생각하고, Stripe로 결제를 사용하고, Shopify 프론트엔드로 스토어를 사용하고, 그것들을 일관된 방식으로 조립하고, 미래에 확장할 수 있는 방식으로 구축할 수 있게 AI를 도와주는 거야.
[03:41] 그래서 그것은 우리가 먼저 생각하고, 우리가 원하는 결과를 얻을 수 있게 해줘, LLM 자체가 그것을 위해 결정을 내리게 하는 대신에. 그래서 나는 이제 개발자로서, 코드에 살고 숨 쉬고 싶어, 맞아? 내 리포에 살고 싶어. 그래서 계획 모드에서 계획할 때처럼, 그것이 내가 해야 할 일인가? 만약 내가 아키텍트나 PM이라면 그것이 의미가 있지만, 만약 내가 개발자이고, 그냥 쓰고 싶다면, 어떻게 스펙 기반 개발에 대해 생각해야 할까? 왜 그것이 엔지니어로서 나에게 중요할까?
[04:11] 왜냐하면 좋은 소프트웨어를 LLM의 도움으로 얻기 위한 핵심 데이터 중 하나는 컨텍스트야. 코드베이스에 대한 컨텍스트, 우리가 한 결정에 대한 컨텍스트. 맞아? 예를 들어, VS Code처럼 복잡한 걸 가져와서, "이 기능을 구현해"라고 LM에게 요청하면, 왜 우리가 특정 색상, 특정 스타일의 상태 바를 선택했는지 컨텍스트가 없어. 아이콘그래피가 특정 방식인 이유는 뭐야? 그래서 LM은 우리가 이전에 스타일링에 대해 어떻게 생각했는지 보고, "아, 이제 이해했어. 이제 이해했어."라고 말할 수 있어. 그래서 그것은 미래 코드가 우리가 원하는 게 되게 하는 데 엄청난 도움이 돼.
[05:33] 나는 그것을 지시와 프롬프트 파일, 내 자신의 가드레일로 생각해. 에이전트가 코드를 만들 때, 그것이 어떻게 다른가? 그것은 그것들을 많이 사용해. 그것은 그것들에 많이 의존해. 왜냐하면 스펙 자체는, 스펙 개발 개념에서, 사람들이 이전 비디오와 블로그 포스트에서 들은 아티팩트가 있어. 스펙.MD 파일이 있어, 구축하려는 기능 요구사항을 개요로 하는 스펙 문서. 계획이 있어, 기술 계획. 그리고 작업 세트가 있어, LLM이 실행해야 할 것들의 목록으로, 우리가 원하는 상태로 가기 위해. 그리고 그것들은 모두 마크다운 파일이야. 그리고 에이전트.MD가 있어, 코드베이스의 지시를 설정하는 거야, 그리고 Copilot CLI로 지원돼. VS Code에서 사용할 수 있어. 에이전트.MD를 모든 곳에서 사용할 수 있어. 모든 곳에서, 맞아? 그래서 표준을 사랑해. 재구현하지 않아도 돼.
[06:33] 그리고 그것은 이러한 컨벤션을 조립해. 그래서 우리가 출시한 GitHub 스펙 키트야. 그리고 다시, 사람들이 말할 때, 그것을 마법 같은 제품으로 생각해. "단지 프롬프트와 스크립트야." 맞아. 그래서 프로젝트에 설치하는 패키지가 아니야. 프로젝트에 뭔가를 설치하지 않아. 맞아. 왜냐하면 정말로 원한다면, 우리는 헬퍼 CLI를 가지고 있어, 나중에 보여줄게. 지정이라고 불러, 또는 지정이라고 발음해. 그리고 CLI는 필수적이지 않아. 왜냐하면 releases로 가서 스펙 키트 템플릿을 스크롤하고, 원하는 에이전트와 스크립트 언어를 찾을 수 있어. 예를 들어, OpenAI의 CodeEx를 사용한다면, 셸 스크립트나 PowerShell이 있어. 그냥 다운로드할 수 있어. 만약 PowerShell을 얻으면, 팝업해서 볼 수 있어. 두 폴더가 있어.
[09:27] CodeEx에 프롬프트가 많이 있어, 스펙, 분석, 체크리스트, 명확화 등. 그리고 메타데이터 파일이 있어, 지정된 것들. 스크립트, 템플릿 등. 다시, 마크다운 파일과 스크립트뿐이야. 아무것도 없어. 그리고 여러 다른 걸 봤어, Claw와 Kodakiler, Gemini. 그래서 이것은 GitHub에서 나오지만, 에이전트 HQ처럼, 모든 에이전트가 사용할 수 있어. 그래서 거의 표준화지만, 각 에이전트가 약간 다르게 설정해야 해. 맞아.
[10:15] 맞아. 그리고 우리는 스펙 키트 v2를 작업 중이야. 그것이 각 에이전트에 대한 커스텀 스크립트의 필요성을 제거할 거야. 모든 게 지정 CLI로 번들될 거고, 그냥 에이전트가 호출할 거야. 하지만 나중에. 그리고 본질적으로, 지정으로 새 프로젝트를 생성할 때, 설치할 수 있어. 웹사이트나 리포에서 지시가 있어. UV를 사용해. 우리는 Python 개발자로서 UV를 좋아해.
[10:46] 그리고 그것은 Python 요구사항이 그 너머에 없어. 프로젝트에 Python이 필요하지 않아. 그리고 다시, 설치할 수 있어. 글로벌로 또는 인스턴스에. 그리고 할 수 있는 건, 지정 init을 하는 거야. 새 프로젝트를 초기화하기 위해. 그리고 프로젝트 이름을 줄 거야. 테스트 데모라고 부를게. 그래서 무슨 일이 일어나는 건, 아름다운 ASCII 아크가 보여, 에이전트 선택. Copilot을 사용할 거야, 물론 Copilot을 보여주기 위해. 그리고 PowerShell을 사용할 거라고 프롬프트돼. 그냥 다운로드할 거야. 완료. 그리고 그것은 기본적으로 우리가 본 zip 파일, releases를 로컬로 가져와서, 추출하고, 프로젝트를 준비한 거야. 그게 다야.
[12:21] 그래서 새 폴더에서 했어. "오, 새 프로젝트야." 그리고 지금 스트리밍하는 대부분의 사람들은, "오, 기존 프로젝트가 있어." 맞아. 그래서 어떻게 해? 예를 들어, 내 웹 앱, 솔루션에 추가하려면? 어떻게 해? 그래서 뒤로 가서 새 폴더를 만들자, 테스트 데모 기존. 그리고 cd 테스트 데모 기존. 여기서 지정 init을 할 수 있어. 그리고 점을 사용할 수 있어. 그게 다야. 그리고 이것은 현재 폴더에서 프로젝트를 부트스트랩할 거야.
[13:02] 그래서 많은 질문이 있어, "새 앱이 있어, 몇 년 동안 출시했어. 스펙 키트가 나에게 의미가 있을까?" 절대적으로. 절대적으로. 기존 프로젝트에 사용할 수 있어. YouTube 비디오도 있어. 링크할게. 그리고 여기서 중요한 건, 콘솔 기반이야. 터미널 인터페이스를 사용해. 그래서 명령을 추측할 필요 없어. 그리고 콘솔에서 파라미터나 인자로 자동화할 수 있어. 하지만 나는 그것을 좋아해, 시작하는 걸 보여주기 위해. 그래서 테스트 데모 프로젝트가 있어. 여기서 VS Code를 바로 열 수 있어. 폴더에서. 그래서 Visual Studio Code 인스턴스에 빛날 거야. 전체 화면으로 만들자. 조금 줌 인. 아름다워. 조금 더. 하지만 특정 것들을 봐. 시작할 때, GitHub 지정 폴더가 있어. 그래서 시작하는 제안 액션이 있어. 명령을 추측할 필요 없어.
[14:08] "헌법"이라고 말해. 시작점. 스펙 키트의 헌법은 프로젝트의 비협상 원칙 세트야. 우리는 그것을 에이전트.MD로 병합 중이야. 그래서 헌법이 아니야. 하지만 지금은. 그리고 목적은 프로젝트의 기능 스펙, 기술 스펙, 작업에 대한 결정을 내릴 때마다, 특정 요구사항을 따르는지 확인하는 거야. 예를 들어, 항상 Azure에 배포하고 싶어. 그래서 이 도구가 사용할 패키지가 Azure 특정이고, 다른 클라우드 제공자를 끌어오지 않게. 배포하는 곳이니까. 그래서 헌법을 설정하는 게 중요해.
[14:41] 그래서 예에서, 팟캐스트 웹사이트를 구축한다고 말할 수 있어. 최소 의존성의 정적 웹사이트야. 그것을 더 복잡하게 만들 수 있어. 하지만 좋은 시작점. 그리고 봐, 최신 스펙 키트에서, 우리는 에이전트 스위처를 사용해. 그래서 각 지시, 각 명령에 대해, 우리는 커스텀 에이전트를 사용해. 봐, 아래에서 자동으로 스위치됐어. 그래서 모든 곳에서 작동한다는 뜻. GitHub에 있다면, 같은 에이전트를 사용할 수 있어. 그래서 프롬프트가 아니야. 맞아. 그리고 에이전트 자체가 프롬프트를 호출해. 헌법을 위해. 그리고 필요한 모든 스크립트를 실행해.
[15:45] 하지만 이것은 핸드오프 같은 걸 할 수 있게 해줘. 헌법이 끝나면, "오, 이제 스펙을 써." "오, 이제 기술 계획을 해." 그리고 점프할 수 있어. 그래서 많은 것들이 여기서 헌법 생성과 디자인에서 볼 수 있어, 나중에. 그리고 그것들은 수동으로 할 수 있어. 그냥 명령을 입력할 수 있어. 하지만 와, 우리는 더 잘 할 수 있어. 그래서 좋은 질문이 있어. 만약 기존 프로젝트에 있다면, 어떻게 기본 스펙을 만들까? 절대적으로 할 수 있어. 그리고 그것이 우리가 프롬프트하는 걸 봤을 때, 완전히 할 수 있어. 먼저 프로젝트를 검사하고, 콘텐츠를 줘. 알았어. 그리고 이제 핸드오프를 제공해. 스펙 헌법에서 사양 구축으로 진행. 아름다워.
[16:44] VS Code 팀이 구현한 걸 외쳐. 정말 멋져. 계획 모드에서 비슷해. 계획을 생성한 다음 다음 걸 해. 그런 다음 XYZ를 풀어. 그래서 헌법에 뭐가 들어있어? 헌법에 뭐가 들어있어? 채팅 모드를 잠시 숨기자. 그래서 정적 웹사이트 정의가 있어. 최소 의존성, 훌륭한 요구사항. 정적 우선도 훌륭한 요구사항. 사랑해. 단순성, 복잡성은 항상 정당화돼야 하고, YAGNI. 거기 있어.
[17:10] 거기 있어. 성능 표준이 있고, 오해가 있어, "이 명령을 사용하면 아티팩트를 생성하고, 이제 채팅으로 가서 변경하라고 해야 해." 마크다운 파일이야. 그냥 스스로 변경해. "3G를 LTE로 변경해"처럼. 맞아. 또는 거버넌스나 개발 워크플로우 같은 것들. "사파리에서 테스트하지 않을 거야"라고 하면 제거해. Dan, 여기에 뭐가 더 들어갈까?
[17:47] 그것은 성능에 대해 몇 가지 했지만, 프레임워크나 그런 것에 대해 말하지 않아. Lighthouse 성능에 대해 말해, 꽤 멋져. 하지만 나는 헌법에 추가할 수 있어, 프로젝트에 대한 비협상 원칙. 예를 들어, 이 프로젝트를 만지는 모든 개발자가 최신 TypeScript 버전을 사용하게 하고 싶어. 여기로 가. 항상 이 로깅 패키지를 사용해. 여기로 가. 프로젝트 전체에 일관되게 하고 싶은 것들. 알았어. 그리고 그것은 기술 요구사항과 비기술 요구사항 모두를 포함할 수 있어. 알았어. 이 경우, 기술 요구사항이 많지 않아. 성능에 대해 있지만, 프레임워크에 대해 말하지 않아. 그것은 Lighthouse 성능에 대해 말해, 꽤 멋져. 하지만 나는 LTS 릴리스에 항상 있는지 확인하고 싶어. 여기서 지정할 수 있어. 또는 정적 사이트이고, 항상 Hugo로 구축하게 하고 싶어.
[18:39] 아, 거기 있어. 그냥 말할 수 있어. 좋아. 하지만 우리는 채팅으로 갈 거고, 이제 사양 구축을 클릭할 수 있어. 그리고 에이전트를 스펙 키트.지정 명령으로 스위치했어. 예. 또는 지정 에이전트. 그리고 나는 여기 플레이스홀더를 제거할 거야. 그리고 팟캐스트 웹사이트를 피처 에피소드로 구축하고 싶다고 말할 수 있어. 다시 최소 포맷. 그리고 입력할 때, 명령을 입력해.
[19:18] 이제 다른 단계에 대한 핸드오프를 줘, 기술 계획을 구축하거나 사양 요구사항을 명확히 하는 거, 매우 중요하고, 나중에 다룰 거야. 왜냐하면 사양을 구축할 때, 우리가 방금 여기서 했듯이, "웹사이트를 구축할 거야"라고 명령을 줘서 스펙 문서를 구축하게 하고, 곧 문서가 여기 있을 거지만, 그 자체로는 충분하지 않아. 뭔가 빠뜨렸을 수 있어. 내가 요구한 걸 모르는 걸 모를 수 있어. 언더 스펙도 문제야. 그래서 여기서 그린필드야.
[19:45] 그래서 여기서 웹사이트를 구축한다고 말했어. 예. 다시, 기존 애플리케이션에 대해 생각해. 먼저 기본 사양을 만들까? 아니면 기능을 분해할까? 예를 들어, 여기서 "페이지 피처 에피소드를 생성해"라고 말했어. 그것을 먼저 생각해야 할까, 처음부터 생성할 때도? 각 사양이 기능처럼, "팟캐스트 웹사이트를 생성해, 그래서 기본 웹사이트를 생성하고, 그런 다음 에피소드에 대한 다른 사양을 가질 거야, 게스트에 대한 다른 사양"이라고? 그것이 어떻게 생각해야 할까? 아니면 모든 걸 하나의 큰 사양에 넣으려고 할까? 내 경험과 다른 프로젝트로 스펙을 실행하면서. 그 워크플로우가 가장 잘 작동할 거야.
[20:39] 좋아. 그리고 이유는 간단해. 컨텍스트를 청크하고 싶어. 모든 걸 하나의 큰 것으로 오프로드할 때, 작동할 수 있지만, 손을 대거나 에이전트 플릿을 가지고 각자 체크하게 해야 해, "이게 맞아? 올바르게 렌더링돼?" 대조적으로, 최소로 시작. 하지만 나중에 다룰 거야. 왜냐하면 그린필드 프로젝트에서 스펙 단계에서 전체 팟캐스트 웹사이트를 구축하고 있어. 엔드투엔드야.
[21:13] 우리는 많은 가정을 하고, 많은 경험 조각을 하지만, 내가 원하는 최소 제품을 분해하기 어려워. MVP야. 예. 하지만 작업의 마지막 단계에 도달하면, 우리는 MVP에 무엇이 들어가야 하는지 스마트하게 식별하고, 그것부터 시작하고, 점진적으로 구축해. 그래서 스스로 그 결정을 내릴 필요 없어. 스펙을 빨리 봐보자. 그래서 새 스펙 폴더를 생성했어. 스펙.MD가 피처 폴더 001 팟캐스트 웹사이트에 있어. 그래서 스펙.MD를 볼 거야.
[21:47] 터미널을 닫고, 모든 변경을 유지할 거야. 왜냐하면 AI를 맹목적으로 신뢰할 테니까. 그래서 그것이 나를 위해 사용자 스토리로 분해했어. 피처 에피소드와 랜딩 페이지를 브라우즈해. 훌륭해. 시나리오가 있어. PM이라면 익숙할 수 있어. 사랑해. 에피소드 디테일. 훌륭해. 에피소드 디테일을 보고 싶다고 지정하지 않았지만, 팟캐스트 웹사이트를 구축하니까 필요하다고 가정했어. 그리고 이것도 흥미로워. 에피소드를 플레이하고 싶어? 오디오 플레이어를 가정할 거야. 그래서 아닐 수 있어. 그래서 그것을 편집할 수 있어. 그리고 이것이 흥미로운 부분이야. 그래서 우리는 엣지 케이스를 가지고 있어, 모든 기능 요구사항. 그것이 내가 쉽게 볼 수 있는 방식으로 분해했어. 하지만 이것을 읽고, "오, 이게 합리적이다. 훌륭해."라고 말해. 하지만 내가 모르는 걸 모르지. 그래서 우리는 명확히 사용해. 내가 모르는 걸 모르지. 내가 아는 걸 모르지. 그래서 명확히 명령을 사용할 거야.
[22:46] 그냥 클릭했어, 그리고 명확히 에이전트를 부트스트랩했어. 그리고 이것이 할 건, LLM을 다시 사용해, 모델을 사용해 스펙을 보고, 빠뜨린 것들을 생각하는 거야. 그리고 여기서 볼 수 있어, 우리를 위해 테이블을 생성했어. 커버리지. 오, 거기 있어. 오늘 내가 가장 좋아하는 버튼. 예. 거기 있어. 사랑해. 그래서 우리가 생성한 테이블을 봐. 코어 사용자 목표가 꽤 명확해, 알았어.
[23:16] 범위 밖의 것들이 정의되지 않았어. 사용자 역할과 페르소나가 정의되지 않았어, 왜냐하면 오, 방문자야, 새로운 vs 리턴? 팟캐스트 소유자야, 맞아. ID와 유니크니스 룰, 여기 빠뜨린 모든 것들, 예, 좋아. 그리고 질문을 시작해. 좋아. 우리는 다섯 질문으로 제한해, 너무 압도하지 않게. 하지만 실제로 질문을 할 거야. 그래서 에피소드 데이터가 어떻게 관리되고 웹사이트에 추가될까?
[23:56] 그리고 옵션을 추천하지만, 다른 옵션도 줘. 오, 멋져. 그래서 RSS에서 임포트할 수 있어, 정적 JSON 정의. 그리고 옵션 B가 합리적이라고 생각해. 그래서 그냥 게으르게 B라고 말할 수 있어. 오, 한 번에 한 질문이야. 오, 멋져. 흥미로워. 좋아. 이 답변을 기록했어. 좋아. 왜냐하면 답변을 기록할 뿐만 아니라, 스펙에 추가하니까. 그래서 여기 추가된 요구사항을 봐.
[24:30] 오, 멋져. 이제 두 번째 질문으로 점프해, 이 웹사이트가 지원해야 하는 예상 에피소드 카탈로그 크기는? 10에서 50 에피소드. D를 좋아해. 인기 팟캐스트로 만들고 싶어서, 200 에피소드를 사용할 거야. 팟캐스팅 포에버. 그래서 게으르게 한 글자로 답할 수 있거나, 스스로 짧은 답변을 줄 수 있어. 그래서 모든 걸 다룰 필요 없어, 아이디어를 얻었으니까. 하지만 그것이 나에게 질문을 하고, 가정을 다시 생각하게 해. 이것이 내가 가장 좋아하는 부분이야, 계획 모드에서 작은 구현을 생각할 때. 이 경우, 더 큰 것들도 계획하고 있어, 그리고 계획 모드에서 계획할 수 있어. 하지만 질문이 좋아, 내가 생각하지 않았을 것들을 생각하게 해.
[25:22] 아마 생각했지만, 프롬프트를 발사해서 생성하지 않았을 거야. 맞아. 그래서 스펙이 좋으면, 기술 계획을 구축할 수 있어. 그리고 이것이 기술 요구사항을 설정하는 곳이야. Hugo로 구축할 거라고 말할 수 있어, 정적 사이트를 원하니까. Hugo를 사랑하고, Tailwind CSS를 스타일링에 추가할 수 있어. 다른 라이브러리를 사용할 수 있어. 하지만 기본적으로, 프로젝트에 원하는 모든 기술 요구사항을 추가하는 곳이야.
[26:00] 그리고 더 자세할수록 좋아, LM이 가정을 피하게. 그리고 다시, 기존 애플리케이션에 있다면, 기술 스펙이 이미 있어, 프로젝트가 있으니까. 그냥 "가서 알아봐"라고 말해. 맞아. 그리고 리뷰해서 예상치 않은 걸 찾을 수 있어. 맞아. 맞아. 맞아. 또한 VS Code가 스마트하게, 단계 세트를 가지고 있어. 왜냐하면 내 계획에 여러 단계가 있으니까, 연구 파일, 데이터 모델, 컨트랙트, 퀵 스타트 생성. 그래서 모든 걸 할 거야. 기술 디테일을 설정하는 게 더 시간-consuming 부분이야. 알았어. 그것이 갈 거고, 많이 생각할 거야. 또한 Opus 모델을 사용하고 있어, 다른 작업에 대해 생각할 때. 하나의 모델에 머무를까? 움직일까?
[26:51] 새로운 모델이 매주, 매일 나오니까, 어떻게 생각해? 왜냐하면 방금 Julia와 VS Code 팟캐스트 녹화를 했고, 같은 걸 이야기했으니까. 다른 시나리오에 어떤 모델을 사용할까? 그것은 정말로 기분에 따라 달라, 또는 더 정확히 말하면, 무엇을 하려고 하는지에 따라 달라.
[27:23] 나는 개인적으로 Anthropic 모델, Claude 모델을 좋아해, 왜냐하면 더 창의적이고, "스펙 문서를 써, 포함할 수 있는 다양한 것들을 생각해"라고 할 때. GPT-5는 예를 들어 더 예약적일 수 있어, 모든 옵션을 주지 않고, 때때로 중단하고, "스펙 섹션을 썼어. 스펙에 대해 계속 생각할까?"라고 하고, 나는 그것을 싫어해.
[27:43] 나는 Claude, Opus나 Sonnet가 그냥 가게 하고, 그런 다음 항상 간섭하고, "아니, 멈춰, 다른 걸 해"라고 말할 수 있어. 하지만 궁극적으로 시나리오에 따라 달라. Sonnet 모델이 C# 코드에 정말 좋다는 걸 봤어, 그리고 GPT-5는 TypeScript에 더 좋을 수 있어. 그래서 스스로 시도해봐야 해.
[28:20] 예, 그리고 그것이 멋진 부분이야, 그것이 소스 코드의 일부가 돼. 그리고 브랜치를 자동으로 생성했어, 그래서 항상 커밋하고 롤백할 수 있어. 그리고 이것이 우리가 스펙 v2에 추가할 걸 보고 있어, 자동 커밋, 왜냐하면 이미 브랜치에 있고, 다른 단계로 갈 때 커밋하니까, 그런 다음 "아니, 상관없어, 되돌려"라고 말할 수 있어. 또한 이 스펙 기반 워크플로우가 리포에 있다는 걸 사랑해, 왜냐하면 그것이 여러 구현, 여러 변형을 구축할 수 있게 해주니까.
[28:53] 팟캐스트 웹사이트를 구축하고 있어, 그리고 스펙에서 멈추고 계획으로 가지 않고, "Hugo로 하나를 원하지만, 다른 하나는 Next.js로 정적 사이트 렌더링을 사용해. 어떻게 될까?" 그리고 그것뿐만 아니라, 성능을 비교하고 싶어. 어느 게 더 빠를까, 내 특정 클라우드 제공자에 더 적합할까? 그리고 하나의 스펙이 있으면, 쉽게 포크하고, 다른 에이전트로 두세 가지 다른 변형을 구현할 수 있어. 예.
[29:25] 그리고 자신의 브랜치를 생성하고, git 워크 트리를 사용할 수 있어. 마법 같은 기능. 모두가 알아야 해. 예. 하지만 예, 이것이 우리가 일하는 방식을 정말 바꿀 거라고 생각해, 왜냐하면 스펙 기반 개발 주변의 많은 워크플로우가 git 기반 작업에 크게 의존하니까. 그리고 git을 알고, 이걸 사용할 수 있어, "스펙이 마음에 들지 않아, 되돌려"라고. 그리고 현대 에이전트는 git 위에서 정말 잘 작동해. 예, 그 아이디어도 좋아. 우리가 이전에 질문에 답할 때, 많은 다른 선택이 있어.
[30:03] 마음속으로, "좋아, 실제로 다른 답변으로 이걸 다른 버전을 하고 싶어, 그런 다음 일반적으로 정제할 수 있어." 맞아. 왜냐하면 스펙으로 특정 구현에 자신을 묶지 않으니까. 스펙은 기술 디테일에서 분리돼. 그래서 들어와서, "이걸 다르게 보이게 하고 싶어. 다른 스택으로 구현하고 싶어."라고 말할 수 있어. 여전히 헌법에 묶여 있어. 비협상처럼, Azure에 성공적으로 배포해야 해.
[30:36] 최소 정적이 아니라고 말하지 않을 거야. 하지만 그것이 포크하고, 각 반복이 독립적으로 작동하고, 각 결과를 보고, 어느 게 더 적합한지 결정할 수 있게 해줘. 정말 멋져. 좋아. 다음 단계는 뭐야? 그래서 이제 요구사항, 체크리스트를 생성하고 있어, 여기서 무슨 일이 일어나고 있어? 예. 계획을 생성할 거야. 기술 디테일을 줄 거야. 그리고 마지막 단계는 작업이야. 계획, 스펙, 모든 디테일에 기반해 개별 작업으로 분해할 거야. 그리고 과거 비디오를 볼 수 있어. 문서가 있을 거야.
[31:12] 하지만 본질적으로, LM이 하나씩 진행하고 구현할 수 있는 분해된 작업 목록을 가질 거야. 예. 그리고 일부는 병렬화할 수 있어. 예, 그것이 플로우야. 스펙 키트로 스펙 기반을 매우 직관적으로 만들려고 해. 단지 사용할 수 있는 몇 가지 명령뿐이야. 좋아. 여기서 나가기 전에, 생성된 코드를 빠르게 탭하고 싶어. 그래서 네 머신을 여기로 가져와, 왜냐하면 가까워. 80/8에 있어. 그래서 이 프로덕션 폴더를 열어, 빨리 걸어가고 싶어.
[31:48] 요구사항이 있어, 컨트랙트, 데이터 모델, 계획. 그것들을 빨리 열 수 있을까? 예, 물론. 그래서 채팅을 여기서 닫자. 터미널을 닫자. 변경을 유지할 거야. 그리고 실제로 채팅을 사용해서 유지할 거야, 파싱하기 쉽게. 하지만 계획을 보면, 기술 컨텍스트가 있어.
[32:18] 템플릿에 기반해 구조화됐어, "Hugo를 사용해야 해, Go 템플릿으로, HTML 5, 일부 의존성, 타겟 플랫폼, 테스트 방식, 스케일, 헌법 체크, 언급한 거, 매우 중요, 놓치지 않게. 왜냐하면 생성한 게 요구사항에 맞는지 확인했으니까, 최소 의존성, 정적, 단순성, 성능, 개발 워크플로우. 그래서 통과했고, 계속할 수 있어. 콘텐츠가 어떻게 배치될지 구조를 개요로 했어. 아키텍처, 에셋, 콘텐츠 자체, 에피소드 서브폴더. 정말 좋아. 모든 디테일이 계획에 캡처됐어, 다시 수정할 수 있어. 데이터 모델 자체가 운영할 엔티티를 정의해, 팟캐스트처럼, 여기 에피소드가 있어, 어느 게 필수인지, 어느 게 아닌지, 다시 매우 편리해. 그리고 뭔가 눈에 띄면 변경할 수 있어. 연구가 매우 중요해. 왜냐하면 Claude Code 같은 에이전트를 사용하면, 실제로 웹으로 나가서 연구할 테니까. 그리고 아마 친구 Burke의 Beast 모드를 사용할 수 있어. 하지만 지금 VS Code에서 하지 않았으니까, 가지고 있는 데이터 코퍼스에서 연구했어. 정말 멋져. 트레이닝에서. 하지만 실제로 보고, "오, 프론트 매터의 최선의 방식은?" "에피소드 포맷은?" "좋아." 키 파인딩과 모든 걸 문서화해. Hugo와 Tailwind CSS 통합. 어떻게? "오, 아마 npm 빌드 스텝을 사용해야 해." 합리적.
[33:39] 모든 게 캡처됐어. 모든 게 이제 폴더에 있으니까, 001 팟캐스트 웹사이트, 이것이 내가 운영할 수 있는 컨텍스트라는 뜻. 그래서 미래에 이 팟캐스트 웹사이트가 구현된 후, 뭔가 변경해야 할 때, 역사적 컨텍스트가 있어, 팟캐스트 에피소드의 데이터 모델에 대해 어떻게 생각했어? 구성은 어떻게? 에피소드는 어디에 있어? 이것이 컨텍스트.
[34:15] 그래서 작업을 생성하고, 그 시점에서, 그냥 평소처럼 구현하는 거야. 작업을 생성하면, 그냥 버튼을 클릭하고, 계획, 스펙, 모든 디테일에 기반해 분해하고, 작업.MD 파일을 생성할 거야. 그냥 작업 목록을 가질 거야. 그리고 그 시점에서, 그것을 구현하라고 요청할 수 있어. 사실 버튼이 있어. 구현. 예. 그리고 백그라운드 에이전트나 원하는 걸로 발사할 수 있어. 정말 멋져.
[34:37] 그래서 이것이 좋아, 왜냐하면 요구사항을 통해, 사양을 통해, 계획 구현을 통해 슈퍼 휴먼 인 더 루프 이해를 가졌으니까. 첫 번째가 아니야, 하지만 기존에, 새로운 기능마다. 그래서 이제 게스트 페이지를 추가하자. 같은 걸 해. 002가 될 거야. 예. 그리고 능력을 추가하고 싶으면, 우리가 보여준 프로세스를 통해 갈 수 있어. 헌법을 생성할 필요 없어, 이미 있어. 그냥 스펙으로 갈 수 있어. 정말 멋져.
[35:05] Dan, 이게 멋져. 온디맨드에 올릴게. 쇼 노트에 링크를 넣고. 아마 Den의 YouTube를 여기에 넣는 방법을 찾아. 그리고 GitHub과 VS Code YouTube에 훌륭한 비디오가 있어. 기본적으로 SpecKit을 검색해. 그리고 거기서 많은 비디오를 찾을 수 있어. Dan, 와서 보여줘서 고마워. 정말 감사해. 고마워. 좋아. Katie와 Christina로 돌아가, 다음 에피소드나 세션으로. 뭐 할까? 뭐 할까 여기서?
[35:39] 세션. 세션. 팟캐스트 모드에 있어. 좋아. 고마워, Den. 그리고 Discord에서 팔로우하고, 채팅에서 질문해, Den도 따라올게.