핵심만 먼저 말하자.

**“RAM에서 밀려난 캐시는 파일 캐시로 내리고, 앱 종료 시 전부 삭제”**
이건 **좋은 방향**이고,
다만 **조건 없이 전부 내리면 안 된다.**
구조를 잘라서 봐야 한다.

---

## 현재 구조의 평가

> 램에 20장 올리고
> 새 캐시 들어오면 오래된 것부터 삭제

이건 **L1 캐시만 있는 상태**다.

* 단순함 ✅
* 구현 쉬움 ✅
* 하지만:

  * 앞뒤 왔다 갔다 할 때 재디코딩 발생 ❌
  * “봤던 사진”을 다시 볼 때 손해 ❌

프로 셀렉션 흐름에서는 이게 체감된다.

---

## 정답에 가까운 구조: 2-Tier 캐시

### Tier 1 — RAM (지금 있는 것)

* 현재 + 앞뒤 N장
* 빠른 탐색용
* LRU 유지

### Tier 2 — Disk File Cache (새로 추가할 것)

* RAM에서 밀려난 것 중 **의미 있는 것만**
* DB ❌
* **파일 캐시 ⭕**

---

## “날리지 말고 파일 캐시로?”에 대한 정확한 답

### ✔️ 한다

하지만 **무조건은 아니다**

---

## 어떤 이미지를 파일 캐시로 내릴까?

### 내려도 되는 것

* 이미 **한 번 화면에 표시된 이미지**
* screen-fit 사이즈
* 동일한 뷰 조건 (줌 1.0, 회전 없음 등)

### 내리면 안 되는 것

* 아직 안 본 이미지 (프리패치 실패분)
* 특수 줌/회전 상태
* 곧 다시 볼 가능성 없는 먼 과거

👉 즉:
**“사용자가 실제로 본 것만”**

---

## 파일 캐시의 성격

* **임시 캐시**
* 앱 실행 동안만 유효
* 종료 시 전체 삭제 ⭕
* 크래시 시 남아도 상관 없음 (다음 실행 시 청소)

Lightroom도 이 철학이다.

---

## 디스크 캐시가 체감에 주는 효과

### 시나리오

* A → B → C → D → E
* 다시 C로 돌아감

#### RAM-only

* C 재디코딩 → 미세한 멈춤

#### RAM + Disk cache

* C 파일 로드 → 거의 즉시 표시

이 차이는 **프로가 바로 느낀다.**

---

## 파일 캐시 구현 포인트 (중요)

### 1. 파일 하나 = 이미지 하나

* 하나의 big cache file ❌
* 개별 파일 ⭕

이유:

* OS 페이지 캐시 활용
* 랜덤 접근 빠름
* 삭제 쉬움

---

### 2. 파일 포맷

* PNG ❌ (느림, 큼)
* JPEG (중간 품질) ⭕
* 또는 raw RGB + header (아주 빠름)

보통:

* 썸네일: JPEG
* screen-fit: JPEG or RGB

---

### 3. 캐시 키

파일명에 반드시 포함:

* 원본 path hash
* mtime
* target size

예:

```
cache/
  ab12cd34_1920x1080.jpg
```

---

## 종료 시 삭제 vs 유지?

### 네 질문에 대한 직접 답변

> 종료 시 삭제를 해야 하나?

**지금 단계에서는 YES**

이유:

* 캐시 무효화 로직 단순
* 버그 추적 쉬움
* 디스크 오염 없음

### 나중에 확장할 수 있는 방향

* “최근 열었던 폴더만 유지”
* “캐시 용량 상한선”
* “사용자 옵션”

하지만 지금은 넣지 마라.
성능보다 복잡도가 먼저 무너진다.

---

## 권장 정책 요약

```
L1 (RAM)
- 현재 + 앞뒤 N
- 20장은 적절

L2 (Disk)
- 실제로 본 이미지
- screen-fit only
- RAM에서 밀려난 것만
- 앱 종료 시 삭제
```

---

## 아주 중요한 기준 하나

> **캐시는 “재사용 확률 × 재생성 비용”이 클 때만 남긴다**

지금 네 경우:

* screen-fit 재생성 비용: 중간
* 재사용 확률: 매우 높음

→ 디스크 캐시는 정답이다.

---

이 다음 단계에서 진짜 성능이 갈리는 질문은 이거다:

**“앞으로 몇 장을 언제 디코딩할지, 사용자의 속도를 어떻게 예측할까?”**

여기까지 오면 이미
“취미 이미지 뷰어” 영역은 완전히 벗어난 상태다.
